#!/bin/sh
# SPDX-FileCopyrightText: 2023 Enapter <developers@enapter.com>
# SPDX-License-Identifier: Apache-2.0

. /usr/share/scripts/enapter-variables

ensure_sync() {
  sync; sync; sync
}

hddrootfs_enabled() {
    if [ -z "${bootparam_rauc_slot}" ]; then
        return 1
    fi
    return 0
}

resolve_device() {
    param="$1"

    if [ "$(echo "$param" | cut -c1-5)" = "UUID=" ]; then
        root_uuid=$(echo "$param" | cut -c6-)
        echo "/dev/disk/by-uuid/$root_uuid"
    elif [ "$(echo "$param" | cut -c1-9)" = "PARTUUID=" ]; then
        root_partuuid=$(echo "$param" | cut -c10-)
        echo "/dev/disk/by-partuuid/$root_partuuid"
    elif [ "$(echo "$param" | cut -c1-10)" = "PARTLABEL=" ]; then
        root_partlabel=$(echo "$param" | cut -c11-)
        echo "/dev/disk/by-partlabel/$root_partlabel"
    elif [ "$(echo "$param" | cut -c1-6)" = "LABEL=" ]; then
        root_label=$(echo "$param" | cut -c7-)
        echo "/dev/disk/by-label/$root_label"
    else
        fatal "ERROR: Failed to find boot device"
    fi
}

wait_for_device() {
    timeout=15
    device="$1"

    debug "Waiting device $device"
    while [ "$timeout" -gt 0 ] && [ ! -e "$device" ]; do
        timeout=$((timeout-1))
        sleep 1
    done

    if [ ! -e "$device" ]; then
        fatal "timed out waiting ${device}"
    fi
}

perform_reset() {
    disk_to_reset="$1"

    if [ -L "$disk_to_reset" ] ; then
      part="$(readlink -f "$disk_to_reset")"

      wipefs -f -a "$part"
      udevadm settle || sleep 3

      i=1
      while [ "${i}" -le 5 ]; do
          mkfs.ext4 -q -F -m0 -L "$disk_data_label" "$part" && return 0 || true
          echo >&2 "$part mkfs failed, looks mounted (attemp $i)"
          sleep 2
          umount "$part" || true

          i=$((i + 1))
      done

      echo >&2 "$part mkfs failed, retries exausted"
      return 1
    fi
}

perform_password_reset() {
    data_disk_mount="/mnt/data_disk"

    if [ -e "$hdd_data_device" ] ; then
        mkdir -p "$data_disk_mount"
        mount "$hdd_data_device" "$data_disk_mount" || return 1

        rm "$data_disk_mount$etc_enapter/$enapter_superuser_password_env_file" || return 1
    fi
}

hddrootfs_run() {
    load_kernel_module overlay
    load_kernel_module squashfs

    if [ -z "$ROOTFS_DIR" ]; then
        fatal "WARNING: No Rootfs variable"
        return
    fi

    if [ -d "$ROOTFS_DIR/dev" ]; then
        fatal "WARNING: Rootfs already mounted"
        return
    fi

    mkdir -p "$root_ro_mount"
    mkdir -p "$app_ro_mount"

    rootfs_device="$(resolve_device "$bootparam_root")"
    appfs_device="$(resolve_device "$bootparam_app")"

    wait_for_device "$rootfs_device"
    wait_for_device "$appfs_device"

    fsck.vfat -pf "$rootfs_device" || true
    fsck.vfat -pf "$appfs_device" || true

    mount "$rootfs_device" -o ro "$root_ro_mount" || fatal "Failed to mount rootfs device"
    mount "$appfs_device" -o ro "$app_ro_mount" || fatal "Failed to mount appfs device"

    debug "Rootfs and Appfs devices mounted"

    if [ -n "$bootparam_factory_reset" ]; then
        perform_reset "$hdd_data_device" || info "[!] Factroy reset failed"
    fi

    if [ -n "$bootparam_password_reset" ]; then
        perform_password_reset || info "[!] Password reset failed"
    fi

    perform_reset "$hdd_data_reset_device" || info "[!] Factory reset failed"

    root_additional_lowerdirs=""
    layer_images=$(find "$app_ro_mount/$layers_base_dir" -name "*.img")

    for layer_image in $layer_images; do
        if [ -n "$layer_image" ]; then
            layer_name=$(basename "$layer_image" ".img")

            info "[!] Mounting $layer_name layer image"

            mkdir -p "$layers_ro_mount/$layer_name"
            mount -o loop -t squashfs "$layer_image" "$layers_ro_mount/$layer_name"

            layer_rootfs_dir="rootfs"

            if [ -d "$layers_ro_mount/$layer_name/$layer_rootfs_dir" ]; then
               root_additional_lowerdirs="$layers_ro_mount/$layer_name/$layer_rootfs_dir:$root_additional_lowerdirs"
            fi
        fi
    done

    mkdir -p "$root_rw_mount"
    mount -o rw,noatime -t tmpfs tmpfs "$root_rw_mount" || fatal "Failed to mount RW rootfs"

    debug "overlayfs/rw mounted"

    debug "rootfs overlayfs additional lowerdirs: $root_additional_lowerdirs"

    mkdir -p "$root_rw_mount/upperdir" "$root_rw_mount/work"
    mount -o "lowerdir=$root_additional_lowerdirs$root_ro_mount,upperdir=$overlayfs_upperdir,workdir=$overlayfs_workdir" -t overlay overlay "$ROOTFS_DIR" || fatal "Failed to mount overlayfs root fs"

    debug "overlayfs mounted"

    mkdir -p "$ROOTFS_DIR/dev"

    # Add links to rootfs
    mkdir -p "$ROOTFS_DIR$app_ro_mount" "$ROOTFS_DIR$root_ro_mount" "$ROOTFS_DIR$root_rw_mount"
    mount --bind "$app_ro_mount" "$ROOTFS_DIR$app_ro_mount"
    mount --bind "$root_ro_mount" "$ROOTFS_DIR$root_ro_mount"
    mount --bind "$root_rw_mount" "$ROOTFS_DIR$root_rw_mount"

    for layer_image in $layer_images; do
        if [ -n "$layer_image" ]; then
            layer_name=$(basename "$layer_image" ".img")

            if [ -d "$layers_ro_mount/$layer_name" ]; then
                mkdir -p "$ROOTFS_DIR$layers_ro_mount/$layer_name"
                mount --bind "$layers_ro_mount/$layer_name" "$ROOTFS_DIR$layers_ro_mount/$layer_name"
            fi
        fi
    done
}
