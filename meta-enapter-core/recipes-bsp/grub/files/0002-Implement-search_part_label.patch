From 5dd0beae16110d6977b171eb84ec8ab9841e24c7 Mon Sep 17 00:00:00 2001
From: Dmitry Myaskovskiy <dmitry@enapter.com>
Date: Tue, 17 Sep 2024 23:14:05 +0200
Subject: [PATCH] Implement search_part_label

Upstream-Status: Inappropriate

Signed-off-by: Dmitrii Miaskovskii <dmitry@enapter.com>
---
 grub-core/Makefile.core.def            |  10 +
 grub-core/commands/probe.c             |   2 +-
 grub-core/commands/search.c            |  29 ++
 grub-core/commands/search_part_label.c |   5 +
 grub-core/commands/search_wrap.c       |   6 +
 grub-core/lib/gpt.c                    | 477 +++++++++++++++++++++++++
 grub-core/partmap/gpt.c                |   4 +-
 include/grub/gpt_partition.h           | 195 +++++++++-
 include/grub/search.h                  |   3 +
 util/grub-install.c                    |   2 +-
 util/grub-probe.c                      |   2 +-
 11 files changed, 711 insertions(+), 24 deletions(-)
 create mode 100644 grub-core/commands/search_part_label.c
 create mode 100644 grub-core/lib/gpt.c

diff --git a/grub-core/Makefile.core.def b/grub-core/Makefile.core.def
index 063ef5dd7..f62b94232 100644
--- a/grub-core/Makefile.core.def
+++ b/grub-core/Makefile.core.def
@@ -930,6 +930,11 @@ module = {
   common = commands/gptsync.c;
 };
 
+module = {
+  name = gpt;
+  common = lib/gpt.c;
+};
+
 module = {
   name = halt;
   nopc = commands/halt.c;
@@ -1106,6 +1111,11 @@ module = {
   common = commands/search_label.c;
 };
 
+module = {
+  name = search_part_label;
+  common = commands/search_part_label.c;
+};
+
 module = {
   name = setpci;
   common = commands/setpci.c;
diff --git a/grub-core/commands/probe.c b/grub-core/commands/probe.c
index be9637f33..f8619e097 100644
--- a/grub-core/commands/probe.c
+++ b/grub-core/commands/probe.c
@@ -119,7 +119,7 @@ grub_cmd_probe (grub_extcmd_context_t ctxt, int argc, char **args)
 	  if (grub_strcmp(dev->disk->partition->partmap->name, "gpt") == 0)
 	    {
 	      struct grub_gpt_partentry entry;
-	      grub_guid_t *guid;
+	      grub_gpt_guid_t *guid;
 
 	      if (grub_disk_read(disk, p->offset, p->index, sizeof(entry), &entry))
 		{
diff --git a/grub-core/commands/search.c b/grub-core/commands/search.c
index 263f1501c..8052f357a 100644
--- a/grub-core/commands/search.c
+++ b/grub-core/commands/search.c
@@ -30,6 +30,9 @@
 #include <grub/i18n.h>
 #include <grub/disk.h>
 #include <grub/partition.h>
+#if defined(DO_SEARCH_PART_LABEL)
+#include <grub/gpt_partition.h>
+#endif
 
 GRUB_MOD_LICENSE ("GPLv3+");
 
@@ -110,6 +113,28 @@ iterate_device (const char *name, void *data)
 	}
       grub_free (buf);
     }
+#elif defined(DO_SEARCH_PART_LABEL)
+    {
+      grub_device_t dev;
+      char *quid;
+
+      dev = grub_device_open (name);
+      if (dev == NULL)
+	{
+	  grub_errno = GRUB_ERR_NONE;
+	  return 0;
+	}
+
+      if (grub_gpt_part_label (dev, &quid) == GRUB_ERR_NONE)
+	{
+	  if (grub_strcmp (quid, ctx->key) == 0)
+		found = 1;
+
+	  grub_free (quid);
+	}
+
+      grub_device_close (dev);
+    }
 #else
     {
       /* SEARCH_FS_UUID or SEARCH_LABEL */
@@ -333,6 +358,8 @@ static grub_command_t cmd;
 
 #ifdef DO_SEARCH_FILE
 GRUB_MOD_INIT(search_fs_file)
+#elif defined(DO_SEARCH_PART_LABEL)
+GRUB_MOD_INIT(search_part_label)
 #elif defined (DO_SEARCH_FS_UUID)
 GRUB_MOD_INIT(search_fs_uuid)
 #else
@@ -347,6 +374,8 @@ GRUB_MOD_INIT(search_label)
 
 #ifdef DO_SEARCH_FILE
 GRUB_MOD_FINI(search_fs_file)
+#elif defined(DO_SEARCH_PART_LABEL)
+GRUB_MOD_FINI(search_part_label)
 #elif defined (DO_SEARCH_FS_UUID)
 GRUB_MOD_FINI(search_fs_uuid)
 #else
diff --git a/grub-core/commands/search_part_label.c b/grub-core/commands/search_part_label.c
new file mode 100644
index 000000000..ca906cbd9
--- /dev/null
+++ b/grub-core/commands/search_part_label.c
@@ -0,0 +1,5 @@
+#define DO_SEARCH_PART_LABEL 1
+#define FUNC_NAME grub_search_part_label
+#define COMMAND_NAME "search.part_label"
+#define HELP_MESSAGE N_("Search devices by partition label. If VARIABLE is specified, the first device found is set to a variable.")
+#include "search.c"
diff --git a/grub-core/commands/search_wrap.c b/grub-core/commands/search_wrap.c
index 318581f3b..b68580e16 100644
--- a/grub-core/commands/search_wrap.c
+++ b/grub-core/commands/search_wrap.c
@@ -36,6 +36,8 @@ static const struct grub_arg_option options[] =
      0, 0},
     {"fs-uuid",		'u', 0, N_("Search devices by a filesystem UUID."),
      0, 0},
+    {"part-label",	'L', 0, N_("Search devices by a partition label."),
+     0, 0},
     {"set",		's', GRUB_ARG_OPTION_OPTIONAL,
      N_("Set a variable to the first device found."), N_("VARNAME"),
      ARG_TYPE_STRING},
@@ -72,6 +74,7 @@ enum options
     SEARCH_FILE,
     SEARCH_LABEL,
     SEARCH_FS_UUID,
+    SEARCH_PART_LABEL,
     SEARCH_SET,
     SEARCH_NO_FLOPPY,
     SEARCH_EFIDISK_ONLY,
@@ -193,6 +196,9 @@ grub_cmd_search (grub_extcmd_context_t ctxt, int argc, char **args)
     grub_search_label (id, var, flags, hints, nhints);
   else if (state[SEARCH_FS_UUID].set)
     grub_search_fs_uuid (id, var, flags, hints, nhints);
+  else if (state[SEARCH_PART_LABEL].set)
+    grub_search_part_label (id, var, state[SEARCH_NO_FLOPPY].set,
+			    hints, nhints);
   else if (state[SEARCH_FILE].set)
     grub_search_fs_file (id, var, flags, hints, nhints);
   else
diff --git a/grub-core/lib/gpt.c b/grub-core/lib/gpt.c
new file mode 100644
index 000000000..93fe61f07
--- /dev/null
+++ b/grub-core/lib/gpt.c
@@ -0,0 +1,477 @@
+/* gpt.c - Read/Verify/Write GUID Partition Tables (GPT).  */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2002,2005,2006,2007,2008  Free Software Foundation, Inc.
+ *  Copyright (C) 2014 CoreOS, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/charset.h>
+#include <grub/crypto.h>
+#include <grub/device.h>
+#include <grub/disk.h>
+#include <grub/misc.h>
+#include <grub/mm.h>
+#include <grub/dl.h>
+#include <grub/msdos_partition.h>
+#include <grub/gpt_partition.h>
+
+GRUB_MOD_LICENSE ("GPLv3+");
+
+static grub_uint8_t grub_gpt_magic[] = GRUB_GPT_HEADER_MAGIC;
+
+
+char *
+grub_gpt_guid_to_str (grub_gpt_guid_t *guid)
+{
+  return grub_xasprintf ("%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
+			 grub_le_to_cpu32 (guid->data1),
+			 grub_le_to_cpu16 (guid->data2),
+			 grub_le_to_cpu16 (guid->data3),
+			 guid->data4[0], guid->data4[1],
+			 guid->data4[2], guid->data4[3],
+			 guid->data4[4], guid->data4[5],
+			 guid->data4[6], guid->data4[7]);
+}
+
+static grub_err_t
+grub_gpt_device_partentry (grub_device_t device,
+			   struct grub_gpt_partentry *entry)
+{
+  grub_disk_t disk = device->disk;
+  grub_partition_t p;
+  grub_err_t err;
+
+  if (!disk || !disk->partition)
+    return grub_error (GRUB_ERR_BUG, "not a partition");
+
+  if (grub_strcmp (disk->partition->partmap->name, "gpt"))
+    return grub_error (GRUB_ERR_BAD_ARGUMENT, "not a GPT partition");
+
+  p = disk->partition;
+  disk->partition = p->parent;
+  err = grub_disk_read (disk, p->offset, p->index, sizeof (*entry), entry);
+  disk->partition = p;
+
+  return err;
+}
+
+grub_err_t
+grub_gpt_part_label (grub_device_t device, char **label)
+{
+  struct grub_gpt_partentry entry;
+  const grub_size_t name_len = ARRAY_SIZE (entry.name);
+  const grub_size_t label_len = name_len * GRUB_MAX_UTF8_PER_UTF16 + 1;
+  grub_size_t i;
+  grub_uint8_t *end;
+
+  if (grub_gpt_device_partentry (device, &entry))
+    return grub_errno;
+
+  *label = grub_malloc (label_len);
+  if (!*label)
+    return grub_errno;
+
+  for (i = 0; i < name_len; i++)
+    entry.name[i] = grub_le_to_cpu16 (entry.name[i]);
+
+  end = grub_utf16_to_utf8 ((grub_uint8_t *) *label, entry.name, name_len);
+  *end = '\0';
+
+  return GRUB_ERR_NONE;
+}
+
+grub_err_t
+grub_gpt_part_uuid (grub_device_t device, char **uuid)
+{
+  struct grub_gpt_partentry entry;
+
+  if (grub_gpt_device_partentry (device, &entry))
+    return grub_errno;
+
+  *uuid = grub_gpt_guid_to_str (&entry.guid);
+  if (!*uuid)
+    return grub_errno;
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_uint64_t
+grub_gpt_size_to_sectors (grub_gpt_t gpt, grub_size_t size)
+{
+  unsigned int sector_size;
+  grub_uint64_t sectors;
+
+  sector_size = 1U << gpt->log_sector_size;
+  sectors = size / sector_size;
+  if (size % sector_size)
+    sectors++;
+
+  return sectors;
+}
+
+static void
+grub_gpt_lecrc32 (grub_uint32_t *crc, const void *data, grub_size_t len)
+{
+  grub_uint32_t crc32_val;
+
+  grub_crypto_hash (GRUB_MD_CRC32, &crc32_val, data, len);
+
+  /* GRUB_MD_CRC32 always uses big endian, gpt is always little.  */
+  *crc = grub_swap_bytes32 (crc32_val);
+}
+
+static void
+grub_gpt_header_lecrc32 (grub_uint32_t *crc, struct grub_gpt_header *header)
+{
+  grub_uint32_t old, new;
+
+  /* crc32 must be computed with the field cleared.  */
+  old = header->crc32;
+  header->crc32 = 0;
+  grub_gpt_lecrc32 (&new, header, sizeof (*header));
+  header->crc32 = old;
+
+  *crc = new;
+}
+
+/* Make sure the MBR is a protective MBR and not a normal MBR.  */
+grub_err_t
+grub_gpt_pmbr_check (struct grub_msdos_partition_mbr *mbr)
+{
+  unsigned int i;
+
+  if (mbr->signature !=
+      grub_cpu_to_le16_compile_time (GRUB_PC_PARTITION_SIGNATURE))
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid MBR signature");
+
+  for (i = 0; i < sizeof (mbr->entries); i++)
+    if (mbr->entries[i].type == GRUB_PC_PARTITION_TYPE_GPT_DISK)
+      return GRUB_ERR_NONE;
+
+  return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid protective MBR");
+}
+
+grub_err_t
+grub_gpt_header_check (struct grub_gpt_header *gpt,
+		       unsigned int log_sector_size)
+{
+  grub_uint32_t crc = 0, size;
+
+  if (grub_memcmp (gpt->magic, grub_gpt_magic, sizeof (grub_gpt_magic)) != 0)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT signature");
+
+  if (gpt->version != GRUB_GPT_HEADER_VERSION)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "unknown GPT version");
+
+  grub_gpt_header_lecrc32 (&crc, gpt);
+
+  if (gpt->crc32 != crc)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT header crc32");
+
+  /* The header size must be between 92 and the sector size.  */
+  size = grub_le_to_cpu32 (gpt->headersize);
+  if (size < 92U || size > (1U << log_sector_size))
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT header size");
+
+  /* The partition entry size must be a multiple of 128.  */
+  size = grub_le_to_cpu32 (gpt->partentry_size);
+  if (size < 128 || size % 128)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT entry size");
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_gpt_read_primary (grub_disk_t disk, grub_gpt_t gpt)
+{
+  grub_disk_addr_t addr;
+
+  /* TODO: The gpt partmap module searches for the primary header instead
+   * of relying on the disk's sector size. For now trust the disk driver
+   * but eventually this code should match the existing behavior.  */
+  gpt->log_sector_size = disk->log_sector_size;
+
+  addr = grub_gpt_sector_to_addr (gpt, 1);
+  if (grub_disk_read (disk, addr, 0, sizeof (gpt->primary), &gpt->primary))
+    return grub_errno;
+
+  if (grub_gpt_header_check (&gpt->primary, gpt->log_sector_size))
+    return grub_errno;
+
+  gpt->status |= GRUB_GPT_PRIMARY_HEADER_VALID;
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_gpt_read_backup (grub_disk_t disk, grub_gpt_t gpt)
+{
+  grub_uint64_t sector;
+  grub_disk_addr_t addr;
+
+  /* Assumes gpt->log_sector_size == disk->log_sector_size  */
+  if (disk->total_sectors != GRUB_DISK_SIZE_UNKNOWN)
+    sector = disk->total_sectors - 1;
+  else if (gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID)
+    sector = grub_le_to_cpu64 (gpt->primary.alternate_lba);
+  else
+    return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,
+		       "Unable to locate backup GPT");
+
+  addr = grub_gpt_sector_to_addr (gpt, sector);
+  if (grub_disk_read (disk, addr, 0, sizeof (gpt->backup), &gpt->backup))
+    return grub_errno;
+
+  if (grub_gpt_header_check (&gpt->backup, gpt->log_sector_size))
+    return grub_errno;
+
+  gpt->status |= GRUB_GPT_BACKUP_HEADER_VALID;
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_gpt_read_entries (grub_disk_t disk, grub_gpt_t gpt,
+		       struct grub_gpt_header *header)
+{
+  struct grub_gpt_partentry *entries = NULL;
+  grub_uint32_t count, size, crc;
+  grub_disk_addr_t addr;
+  grub_size_t entries_size;
+
+  /* Grub doesn't include calloc, hence the manual overflow check.  */
+  count = grub_le_to_cpu32 (header->maxpart);
+  size = grub_le_to_cpu32 (header->partentry_size);
+  entries_size = count *size;
+  if (size && entries_size / size != count)
+    {
+      grub_error (GRUB_ERR_OUT_OF_MEMORY, N_("out of memory"));
+      goto fail;
+    }
+
+  /* Double check that the header was validated properly.  */
+  if (entries_size < GRUB_GPT_DEFAULT_ENTRIES_SIZE)
+    return grub_error (GRUB_ERR_BUG, "invalid GPT entries table size");
+
+  entries = grub_malloc (entries_size);
+  if (!entries)
+    goto fail;
+
+  addr = grub_gpt_sector_to_addr (gpt, grub_le_to_cpu64 (header->partitions));
+  if (grub_disk_read (disk, addr, 0, entries_size, entries))
+    goto fail;
+
+  grub_gpt_lecrc32 (&crc, entries, entries_size);
+
+  if (crc != header->partentry_crc32)
+    {
+      grub_error (GRUB_ERR_BAD_PART_TABLE, "invalid GPT entry crc32");
+      goto fail;
+    }
+
+  grub_free (gpt->entries);
+  gpt->entries = entries;
+  gpt->entries_size = entries_size;
+  return GRUB_ERR_NONE;
+
+fail:
+  grub_free (entries);
+  return grub_errno;
+}
+
+grub_gpt_t
+grub_gpt_read (grub_disk_t disk)
+{
+  grub_gpt_t gpt;
+
+  gpt = grub_zalloc (sizeof (*gpt));
+  if (!gpt)
+    goto fail;
+
+  if (grub_disk_read (disk, 0, 0, sizeof (gpt->mbr), &gpt->mbr))
+    goto fail;
+
+  /* Check the MBR but errors aren't reported beyond the status bit.  */
+  if (grub_gpt_pmbr_check (&gpt->mbr))
+    grub_errno = GRUB_ERR_NONE;
+  else
+    gpt->status |= GRUB_GPT_PROTECTIVE_MBR;
+
+  /* If both the primary and backup fail report the primary's error.  */
+  if (grub_gpt_read_primary (disk, gpt))
+    {
+      grub_error_push ();
+      grub_gpt_read_backup (disk, gpt);
+      grub_error_pop ();
+    }
+  else
+    grub_gpt_read_backup (disk, gpt);
+
+  /* If either succeeded clear any possible error from the other.  */
+  if (gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID ||
+      gpt->status & GRUB_GPT_BACKUP_HEADER_VALID)
+    grub_errno = GRUB_ERR_NONE;
+  else
+    goto fail;
+
+  /* Similarly, favor the value or error from the primary table.  */
+  if (gpt->status & GRUB_GPT_BACKUP_HEADER_VALID &&
+      !grub_gpt_read_entries (disk, gpt, &gpt->backup))
+    gpt->status |= GRUB_GPT_BACKUP_ENTRIES_VALID;
+
+  grub_errno = GRUB_ERR_NONE;
+  if (gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID &&
+      !grub_gpt_read_entries (disk, gpt, &gpt->primary))
+    gpt->status |= GRUB_GPT_PRIMARY_ENTRIES_VALID;
+
+  if (gpt->status & GRUB_GPT_PRIMARY_ENTRIES_VALID ||
+      gpt->status & GRUB_GPT_BACKUP_ENTRIES_VALID)
+    grub_errno = GRUB_ERR_NONE;
+  else
+    goto fail;
+
+  return gpt;
+
+fail:
+  grub_gpt_free (gpt);
+  return NULL;
+}
+
+grub_err_t
+grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt)
+{
+  grub_uint64_t backup_header, backup_entries;
+
+  if (disk->log_sector_size != gpt->log_sector_size)
+    return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,
+		       "GPT sector size must match disk sector size");
+
+  if (!(gpt->status & GRUB_GPT_PRIMARY_ENTRIES_VALID ||
+        gpt->status & GRUB_GPT_BACKUP_ENTRIES_VALID))
+    return grub_error (GRUB_ERR_BUG, "No valid GPT entries");
+
+  if (gpt->status & GRUB_GPT_PRIMARY_HEADER_VALID)
+    {
+      backup_header = grub_le_to_cpu64 (gpt->primary.alternate_lba);
+      grub_memcpy (&gpt->backup, &gpt->primary, sizeof (gpt->backup));
+    }
+  else if (gpt->status & GRUB_GPT_BACKUP_HEADER_VALID)
+    {
+      backup_header = grub_le_to_cpu64 (gpt->backup.header_lba);
+      grub_memcpy (&gpt->primary, &gpt->backup, sizeof (gpt->primary));
+    }
+  else
+    return grub_error (GRUB_ERR_BUG, "No valid GPT header");
+
+  /* Relocate backup to end if disk whenever possible.  */
+  if (disk->total_sectors != GRUB_DISK_SIZE_UNKNOWN)
+    backup_header = disk->total_sectors - 1;
+
+  backup_entries = backup_header -
+    grub_gpt_size_to_sectors (gpt, gpt->entries_size);
+
+  /* Update/fixup header and partition table locations.  */
+  gpt->primary.header_lba = grub_cpu_to_le64_compile_time (1);
+  gpt->primary.alternate_lba = grub_cpu_to_le64 (backup_header);
+  gpt->primary.partitions = grub_cpu_to_le64_compile_time (2);
+  gpt->backup.header_lba = gpt->primary.alternate_lba;
+  gpt->backup.alternate_lba = gpt->primary.header_lba;
+  gpt->backup.partitions = grub_cpu_to_le64 (backup_entries);
+
+  /* Recompute checksums.  */
+  if (grub_gpt_update_checksums (gpt))
+    return grub_errno;
+
+  /* Sanity check.  */
+  if (grub_gpt_header_check (&gpt->primary, gpt->log_sector_size))
+    return grub_error (GRUB_ERR_BUG, "Generated invalid GPT primary header");
+
+  if (grub_gpt_header_check (&gpt->backup, gpt->log_sector_size))
+    return grub_error (GRUB_ERR_BUG, "Generated invalid GPT backup header");
+
+  gpt->status |= GRUB_GPT_BOTH_VALID;
+  return GRUB_ERR_NONE;
+}
+
+grub_err_t
+grub_gpt_update_checksums (grub_gpt_t gpt)
+{
+  grub_uint32_t crc;
+
+  /* Writing headers larger than our header structure are unsupported.  */
+  gpt->primary.headersize =
+    grub_cpu_to_le32_compile_time (sizeof (gpt->primary));
+  gpt->backup.headersize =
+    grub_cpu_to_le32_compile_time (sizeof (gpt->backup));
+
+  grub_gpt_lecrc32 (&crc, gpt->entries, gpt->entries_size);
+
+  gpt->primary.partentry_crc32 = crc;
+  gpt->backup.partentry_crc32 = crc;
+
+  grub_gpt_header_lecrc32 (&gpt->primary.crc32, &gpt->primary);
+  grub_gpt_header_lecrc32 (&gpt->backup.crc32, &gpt->backup);
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_gpt_write_table (grub_disk_t disk, grub_gpt_t gpt,
+		      struct grub_gpt_header *header)
+{
+  grub_disk_addr_t addr;
+
+  if (grub_le_to_cpu32 (header->headersize) != sizeof (*header))
+    return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,
+		       "Header size is %u, must be %u",
+		       grub_le_to_cpu32 (header->headersize),
+		       sizeof (*header));
+
+  addr = grub_gpt_sector_to_addr (gpt, grub_le_to_cpu64 (header->header_lba));
+  if (grub_disk_write (disk, addr, 0, sizeof (*header), header))
+    return grub_errno;
+
+  addr = grub_gpt_sector_to_addr (gpt, grub_le_to_cpu64 (header->partitions));
+  if (grub_disk_write (disk, addr, 0, gpt->entries_size, gpt->entries))
+    return grub_errno;
+
+  return GRUB_ERR_NONE;
+}
+
+grub_err_t
+grub_gpt_write (grub_disk_t disk, grub_gpt_t gpt)
+{
+  /* TODO: update/repair protective MBRs too.  */
+
+  if (!(gpt->status & GRUB_GPT_BOTH_VALID))
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "Invalid GPT data");
+
+  if (grub_gpt_write_table (disk, gpt, &gpt->primary))
+    return grub_errno;
+
+  if (grub_gpt_write_table (disk, gpt, &gpt->backup))
+    return grub_errno;
+
+  return GRUB_ERR_NONE;
+}
+
+void
+grub_gpt_free (grub_gpt_t gpt)
+{
+  if (!gpt)
+    return;
+
+  grub_free (gpt->entries);
+  grub_free (gpt);
+}
diff --git a/grub-core/partmap/gpt.c b/grub-core/partmap/gpt.c
index 426f616ae..efbfb0ade 100644
--- a/grub-core/partmap/gpt.c
+++ b/grub-core/partmap/gpt.c
@@ -36,10 +36,10 @@ static grub_uint8_t grub_gpt_magic[8] =
     0x45, 0x46, 0x49, 0x20, 0x50, 0x41, 0x52, 0x54
   };
 
-static const grub_guid_t grub_gpt_partition_type_empty = GRUB_GPT_PARTITION_TYPE_EMPTY;
+static const grub_gpt_guid_t grub_gpt_partition_type_empty = GRUB_GPT_PARTITION_TYPE_EMPTY;
 
 #ifdef GRUB_UTIL
-static const grub_guid_t grub_gpt_partition_type_bios_boot = GRUB_GPT_PARTITION_TYPE_BIOS_BOOT;
+static const grub_gpt_guid_t grub_gpt_partition_type_bios_boot = GRUB_GPT_PARTITION_TYPE_BIOS_BOOT;
 #endif
 
 /* 512 << 7 = 65536 byte sectors.  */
diff --git a/include/grub/gpt_partition.h b/include/grub/gpt_partition.h
index 292ea03f1..21359f08a 100644
--- a/include/grub/gpt_partition.h
+++ b/include/grub/gpt_partition.h
@@ -21,25 +21,55 @@
 
 #include <grub/types.h>
 #include <grub/partition.h>
+#include <grub/msdos_partition.h>
 
-#define GRUB_GPT_PARTITION_TYPE_EMPTY \
-  { 0x0, 0x0, 0x0, \
-    { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 } \
+struct grub_gpt_guid
+{
+  grub_uint32_t data1;
+  grub_uint16_t data2;
+  grub_uint16_t data3;
+  grub_uint8_t data4[8];
+} __attribute__ ((aligned(8)));
+typedef struct grub_gpt_guid grub_gpt_guid_t;
+typedef struct grub_gpt_guid grub_gpt_part_type_t;
+
+/* Format the raw little-endian GUID as a newly allocated string.  */
+char * grub_gpt_guid_to_str (grub_gpt_guid_t *guid);
+
+
+#define GRUB_GPT_GUID_INIT(a, b, c, d1, d2, d3, d4, d5, d6, d7, d8)  \
+  {					\
+    grub_cpu_to_le32_compile_time (a),	\
+    grub_cpu_to_le16_compile_time (b),	\
+    grub_cpu_to_le16_compile_time (c),	\
+    { d1, d2, d3, d4, d5, d6, d7, d8 }	\
   }
 
+#define GRUB_GPT_PARTITION_TYPE_EMPTY \
+  GRUB_GPT_GUID_INIT (0x0, 0x0, 0x0,  \
+      0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0)
+
+#define GRUB_GPT_PARTITION_TYPE_EFI_SYSTEM \
+  GRUB_GPT_GUID_INIT (0xc12a7328, 0xf81f, 0x11d2, \
+      0xba, 0x4b, 0x00, 0xa0, 0xc9, 0x3e, 0xc9, 0x3b)
+
 #define GRUB_GPT_PARTITION_TYPE_BIOS_BOOT \
-  { grub_cpu_to_le32_compile_time (0x21686148), \
-      grub_cpu_to_le16_compile_time (0x6449), \
-      grub_cpu_to_le16_compile_time (0x6e6f),	       \
-    { 0x74, 0x4e, 0x65, 0x65, 0x64, 0x45, 0x46, 0x49 } \
-  }
+  GRUB_GPT_GUID_INIT (0x21686148, 0x6449, 0x6e6f, \
+      0x74, 0x4e, 0x65, 0x65, 0x64, 0x45, 0x46, 0x49)
 
 #define GRUB_GPT_PARTITION_TYPE_LDM \
-  { grub_cpu_to_le32_compile_time (0x5808C8AAU),\
-      grub_cpu_to_le16_compile_time (0x7E8F), \
-      grub_cpu_to_le16_compile_time (0x42E0),	       \
-	{ 0x85, 0xD2, 0xE1, 0xE9, 0x04, 0x34, 0xCF, 0xB3 }	\
-  }
+  GRUB_GPT_GUID_INIT (0x5808c8aa, 0x7e8f, 0x42e0, \
+      0x85, 0xd2, 0xe1, 0xe9, 0x04, 0x34, 0xcf, 0xb3)
+
+#define GRUB_GPT_PARTITION_TYPE_USR_X86_64 \
+  GRUB_GPT_GUID_INIT (0x5dfbf5f4, 0x2848, 0x4bac, \
+      0xaa, 0x5e, 0x0d, 0x9a, 0x20, 0xb7, 0x45, 0xa6)
+
+#define GRUB_GPT_HEADER_MAGIC \
+  { 0x45, 0x46, 0x49, 0x20, 0x50, 0x41, 0x52, 0x54 }
+
+#define GRUB_GPT_HEADER_VERSION	\
+  grub_cpu_to_le32_compile_time (0x00010000U)
 
 struct grub_gpt_header
 {
@@ -48,11 +78,11 @@ struct grub_gpt_header
   grub_uint32_t headersize;
   grub_uint32_t crc32;
   grub_uint32_t unused1;
-  grub_uint64_t primary;
-  grub_uint64_t backup;
+  grub_uint64_t header_lba;
+  grub_uint64_t alternate_lba;
   grub_uint64_t start;
   grub_uint64_t end;
-  grub_uint8_t guid[16];
+  grub_gpt_guid_t guid;
   grub_uint64_t partitions;
   grub_uint32_t maxpart;
   grub_uint32_t partentry_size;
@@ -61,18 +91,145 @@ struct grub_gpt_header
 
 struct grub_gpt_partentry
 {
-  grub_guid_t type;
-  grub_guid_t guid;
+  grub_gpt_part_type_t type;
+  grub_gpt_guid_t guid;
   grub_uint64_t start;
   grub_uint64_t end;
   grub_uint64_t attrib;
-  char name[72];
+  grub_uint16_t name[36];
+} GRUB_PACKED;
+
+enum grub_gpt_part_attr_offset
+{
+  /* Standard partition attribute bits defined by UEFI.  */
+  GRUB_GPT_PART_ATTR_OFFSET_REQUIRED			= 0,
+  GRUB_GPT_PART_ATTR_OFFSET_NO_BLOCK_IO_PROTOCOL	= 1,
+  GRUB_GPT_PART_ATTR_OFFSET_LEGACY_BIOS_BOOTABLE	= 2,
+
+  /* De facto standard attribute bits defined by Microsoft and reused by
+   * http://www.freedesktop.org/wiki/Specifications/DiscoverablePartitionsSpec */
+  GRUB_GPT_PART_ATTR_OFFSET_READ_ONLY			= 60,
+  GRUB_GPT_PART_ATTR_OFFSET_NO_AUTO			= 63,
+
+  /* Partition attributes for priority based selection,
+   * Currently only valid for PARTITION_TYPE_USR_X86_64.
+   * TRIES_LEFT and PRIORITY are 4 bit wide fields.  */
+  GRUB_GPT_PART_ATTR_OFFSET_GPTPRIO_PRIORITY		= 48,
+  GRUB_GPT_PART_ATTR_OFFSET_GPTPRIO_TRIES_LEFT		= 52,
+  GRUB_GPT_PART_ATTR_OFFSET_GPTPRIO_SUCCESSFUL		= 56,
 };
 
+/* Helpers for reading/writing partition attributes.  */
+static inline grub_uint64_t
+grub_gpt_entry_attribute (struct grub_gpt_partentry *entry,
+			  enum grub_gpt_part_attr_offset offset,
+			  unsigned int bits)
+{
+  grub_uint64_t attrib = grub_le_to_cpu64 (entry->attrib);
+
+  return (attrib >> offset) & ((1ULL << bits) - 1);
+}
+
+static inline void
+grub_gpt_entry_set_attribute (struct grub_gpt_partentry *entry,
+			      grub_uint64_t value,
+			      enum grub_gpt_part_attr_offset offset,
+			      unsigned int bits)
+{
+  grub_uint64_t attrib, mask;
+
+  mask = (((1ULL << bits) - 1) << offset);
+  attrib = grub_le_to_cpu64 (entry->attrib) & ~mask;
+  attrib |= ((value << offset) & mask);
+  entry->attrib = grub_cpu_to_le64 (attrib);
+}
+
+/* Basic GPT partmap module.  */
 grub_err_t
 grub_gpt_partition_map_iterate (grub_disk_t disk,
 				grub_partition_iterate_hook_t hook,
 				void *hook_data);
 
+/* Advanced GPT library.  */
+typedef enum grub_gpt_status
+  {
+    GRUB_GPT_PROTECTIVE_MBR         = 0x01,
+    GRUB_GPT_HYBRID_MBR             = 0x02,
+    GRUB_GPT_PRIMARY_HEADER_VALID   = 0x04,
+    GRUB_GPT_PRIMARY_ENTRIES_VALID  = 0x08,
+    GRUB_GPT_BACKUP_HEADER_VALID    = 0x10,
+    GRUB_GPT_BACKUP_ENTRIES_VALID   = 0x20,
+  } grub_gpt_status_t;
+
+#define GRUB_GPT_MBR_VALID (GRUB_GPT_PROTECTIVE_MBR|GRUB_GPT_HYBRID_MBR)
+#define GRUB_GPT_PRIMARY_VALID \
+  (GRUB_GPT_PRIMARY_HEADER_VALID|GRUB_GPT_PRIMARY_ENTRIES_VALID)
+#define GRUB_GPT_BACKUP_VALID \
+  (GRUB_GPT_BACKUP_HEADER_VALID|GRUB_GPT_BACKUP_ENTRIES_VALID)
+#define GRUB_GPT_BOTH_VALID (GRUB_GPT_PRIMARY_VALID|GRUB_GPT_BACKUP_VALID)
+
+/* UEFI requires the entries table to be at least 16384 bytes for a
+ * total of 128 entries given the standard 128 byte entry size.  */
+#define GRUB_GPT_DEFAULT_ENTRIES_SIZE	16384
+#define GRUB_GPT_DEFAULT_ENTRIES_LENGTH	\
+  (GRUB_GPT_DEFAULT_ENTRIES_SIZE / sizeof (struct grub_gpt_partentry))
+
+struct grub_gpt
+{
+  /* Bit field indicating which structures on disk are valid.  */
+  grub_gpt_status_t status;
+
+  /* Protective or hybrid MBR.  */
+  struct grub_msdos_partition_mbr mbr;
+
+  /* Each of the two GPT headers.  */
+  struct grub_gpt_header primary;
+  struct grub_gpt_header backup;
+
+  /* Only need one entries table, on disk both copies are identical.  */
+  struct grub_gpt_partentry *entries;
+  grub_size_t entries_size;
+
+  /* Logarithm of sector size, in case GPT and disk driver disagree.  */
+  unsigned int log_sector_size;
+};
+typedef struct grub_gpt *grub_gpt_t;
+
+/* Translate GPT sectors to GRUB's 512 byte block addresses.  */
+static inline grub_disk_addr_t
+grub_gpt_sector_to_addr (grub_gpt_t gpt, grub_uint64_t sector)
+{
+  return (sector << (gpt->log_sector_size - GRUB_DISK_SECTOR_BITS));
+}
+
+/* Allocates and fills new grub_gpt structure, free with grub_gpt_free.  */
+grub_gpt_t grub_gpt_read (grub_disk_t disk);
+
+/* Sync up primary and backup headers, recompute checksums.  */
+grub_err_t grub_gpt_repair (grub_disk_t disk, grub_gpt_t gpt);
+
+/* Recompute checksums, must be called after modifying GPT data.  */
+grub_err_t grub_gpt_update_checksums (grub_gpt_t gpt);
+
+/* Write headers and entry tables back to disk.  */
+grub_err_t grub_gpt_write (grub_disk_t disk, grub_gpt_t gpt);
+
+void grub_gpt_free (grub_gpt_t gpt);
+
+grub_err_t grub_gpt_pmbr_check (struct grub_msdos_partition_mbr *mbr);
+grub_err_t grub_gpt_header_check (struct grub_gpt_header *gpt,
+				  unsigned int log_sector_size);
+
+
+/* Utilities for simple partition data lookups, usage is intended to
+ * be similar to fs->label and fs->uuid functions.  */
+
+/* Return the partition label of the device DEVICE in LABEL.
+ * The label is in a new buffer and should be freed by the caller.  */
+grub_err_t grub_gpt_part_label (grub_device_t device, char **label);
+
+/* Return the partition uuid of the device DEVICE in UUID.
+ * The uuid is in a new buffer and should be freed by the caller.  */
+grub_err_t grub_gpt_part_uuid (grub_device_t device, char **uuid);
 
 #endif /* ! GRUB_GPT_PARTITION_HEADER */
diff --git a/include/grub/search.h b/include/grub/search.h
index ffd2411ca..39d027cf3 100644
--- a/include/grub/search.h
+++ b/include/grub/search.h
@@ -35,5 +35,8 @@ void grub_search_fs_uuid (const char *key, const char *var,
 void grub_search_label (const char *key, const char *var,
 			enum search_flags flags,
 			char **hints, unsigned nhints);
+void grub_search_part_label (const char *key, const char *var,
+			     enum search_flags flags,
+			     char **hints, unsigned nhints);
 
 #endif
diff --git a/util/grub-install.c b/util/grub-install.c
index 7dc5657bb..9901651cf 100644
--- a/util/grub-install.c
+++ b/util/grub-install.c
@@ -728,7 +728,7 @@ is_prep_partition (grub_device_t dev)
       if (grub_disk_read (dev->disk, p->offset, p->index,
 			  sizeof (gptdata), &gptdata) == 0)
 	{
-	  const grub_guid_t template = {
+	  const grub_gpt_guid_t template = {
 	    grub_cpu_to_le32_compile_time (0x9e1a2d38),
 	    grub_cpu_to_le16_compile_time (0xc612),
 	    grub_cpu_to_le16_compile_time (0x4316),
diff --git a/util/grub-probe.c b/util/grub-probe.c
index 65c1ca3f8..e5ead0908 100644
--- a/util/grub-probe.c
+++ b/util/grub-probe.c
@@ -133,7 +133,7 @@ get_targets_string (void)
 }
 
 static int
-print_gpt_guid (grub_guid_t guid)
+print_gpt_guid (grub_gpt_guid_t guid)
 {
   guid.data1 = grub_le_to_cpu32 (guid.data1);
   guid.data2 = grub_le_to_cpu16 (guid.data2);
-- 
2.45.1

